<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>链表</title>
</head>
<body>
    
</body>
<script>
  function LinkedList(){
      // 内部类
      function Node(element){
        this.element = element;
        this.next = null;
      }
      //属性
      this.head = null;
      this.length = 0;

      //append(element)
      LinkedList.prototype.append = function(element){
        let newNode = new Node(element)
        //1. 判断是否添加的是第一个节点
        if(this.length == 0){
            this.head = newNode;
        }else{
        //2.不是第一个节点。通过while循环找到最后一个节点。    
            let current = this.head; // this.head指向的是一个节点。因此这里current代表一个节点
            while(current.next){
                current = current.next;
            }
            // 让最后节点的next指向新的节点
            current.next = newNode;
        }
        this.length += 1;
      }


      //toString方法
      LinkedList.prototype.toString = function(){
          let current = this.head;
          let str = ''
          while(current){
            str += current.element + '->';
            current = current.next;
          }
          return str;
      }

      //insert方法
      LinkedList.prototype.insert = function(position,element){
          //1. 对position进行越界判断
          if(position < 0 || position > this.length){
              return false;
          }

          //2. 创建新的节点
          let newNode = new Node(element);
          //3. 判断插入的元素是否是第一个
          if(position == 0){
              let current = this.head;// 保存原来的第一个
              this.head = newNode;
              newNode.next = current;
          }else{
              let index = 0;
              let previous = null;//一开始head的前一个就是null
              let current = this.head;
              while(index++ < position){
                  previous = current;
                  //索引值每加一次1，current就指向下一个next
                  current = current.next;
              }
              newNode.next = current;
              previous.next = newNode;
          }
          //4. length+1
          this.length += 1;
          return true;
      }

      //get(position):获取对应位置的元素
      LinkedList.prototype.get = function(position){
          //1. 边界条件的判断
          if(position < 0 || position >= this.length){
              return false;
          }
          //2. 获取指定position对应节点的内容
          let index = 0;
          let current = this.head;
          while(index < position){
            index += 1;
            current = current.next;
          }
          return current.element;
      }
       //indexOf(element):返回元素在链表中的索引，如果链表中没有该元素则返回-1
       Linkedlist.prototype.indexOf = function(element){
            let current = this.head;
            let index = 0;
            //使用current作为循环结束的条件 current等于null的时候表示查找结束了，退出循环
            while(current){
                if(current.element == element){
                    return index;
                }
                current = current.next;
                index += 1;
            }
            return -1;
        }
       //    update(position,element):修改元素某个位置的值
       LinkedList.prototype.update = function(position,element){
           if(position < -1 || position >= this.length){
               return false;
           }
           let index = 0;
           let current = this.head;
           while(index < position){
               index += 1;
               current = current.next;
           }
           current.element = element;
           return true
       }

       //   removeAt(position):从链表的特定位置移除一项
       LinkedList.prototype.removeAt = function(position){
           // 1. 边界判断
           if(position < -1 || position >= this.length){
               return false;
           }
           // 2. 找到链表的特定位置
           let index = 0;
           let current = this.head;
           let previous = null;
           // 如果删除的元素是第一个元素
           if(position == 0){
               this.head = current.next;
           }else{
                //如果删除的不是第一个元素
                while(index < position){
                    index += 1;
                    previous = current;
                    current = current.next;
                }
                previous.next = current.next;
           }
           this.length -= 1;
           return current.element;
       }
       
       // remove(element):从链表中移除某一项
       LinkedList.prototype.remove = function(element){
           let current = this.head;
           let previous = null;
           // 如果要移除的元素正好是第一项
           if(current.element == element){
               this.head = current.next;
           }else{
               while(current.element != element){
                   if(!current.next){
                       return -1;
                   }
                   previous = current;
                   current = current.next;
               }
               previous.next = current.next;
               
           }
           this.length -= 1;
           return current.element;
       }

       LinkedList.prototype.isEmpty = function(){
           return this.length == 0;
       }

       LinkedList.prototype.size = function(){
           return this.length;
       }
  }


  let linkedList = new LinkedList();
  linkedList.append('a');
  linkedList.append('b');
  linkedList.append('c');
  linkedList.append('d');
  alert(linkedList.toString())
//   linkedList.insert(3,'d')
//   alert(linkedList.toString())
//   console.log(linkedList.get(2))
//   console.log('元素f的索引是'+linkedList.indexOf('f'))

//   console.log('.....update.......')
//   linkedList.update(2,'update');
//   linkedList.removeAt(0)
  linkedList.remove('d')
  console.log( linkedList.remove('f'))
  alert(linkedList.toString())

</script>
</html>