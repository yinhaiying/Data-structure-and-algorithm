<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>双向链表的封装</title>
</head>
<body>
    
</body>
<script>

    function DoublyLinkedlist(){
        // 属性
        this.head = null; //默认情况下(也就是没有节点的情况下)指向null
        this.tail = null;
        this.length = 0;
        
        function Node(ele){
            this.element = ele;
            this.prev = null;
            this.next = null;
        }

        // append(ele)
        DoublyLinkedlist.prototype.append = function(ele){
          let newNode = new Node(ele);
          //如果链表为空
          if(this.length == 0){
              this.head = newNode;
              this.tail = newNode;
          }else{
              newNode.prev = this.tail;
              this.tail.next = newNode;
              this.tail = newNode;
          }
          this.length += 1;
        }

        //insert(element)
        DoublyLinkedlist.prototype.insert = function(position,element){
            if(position < 0 || position > this.length){
                return false;
            }
            let newNode = new Node(element);
            let prev = null;
            let current = null;
            if(this.length == 0){
                this.head = newNode;
                this.tail = newNode;
            }else{
                //如果是在链表头插入
                if(position == 0){
                    current = this.head;
                    current.prev = newNode; // 原来的第一个节点变成了第二个节点，因此它具有prev发生了变化
                    newNode.next = current;//新插入的节点的next指向原来的第一个节点
                    this.head = newNode; // head指针应该指向第一个节点也就是新插入的节点。
                }else if(position == this.length){
                //如果是在链表尾部添加
                    current = this.tail;
                    newNode.prev = current;//新插入节点的Prev应该指向原来的最后一个
                    current.next = newNode;//原来最后一个的next应该指向新插入的节点
                    this.tail = newNode;//tail指针指向最后一个节点，也就是新插入的节点
                }else{
                    let index = 0;
                    current = this.head;
                    while(index < position){
                        index += 1;
                        prev = current;
                        current = current.next;
                    }
                    current.prev = newNode;
                    newNode.next = current;
                    newNode.prev = prev;
                    prev.next = newNode;
                }
            }

            this.length += 1;
            return true;
        }

        // get(position)
        DoublyLinkedlist.prototype.get = function(position){
           if(position < 0 || position >= this.length){
               return null;
           }
           let flag = this.length/2 > position;  //从前往后查找更加简便
           let current = null;
           let index = 0;
           if(flag){
               //从前往后查找
               console.log('前面查找')
                current = this.head;
                while(index < position){
                    index += 1;
                    current = current.next;
                }
                return current.element;
           }else{
               //从后往前查找
               console.log('后面查找')
                current = this.tail;
                while(index < this.length - 1 - position){
                    index += 1;
                    current = current.prev;
                }
                return current.element;
           }

        }
        // indexOf(element)返回指定元素的索引值
        DoublyLinkedlist.prototype.indexOf = function(element){
            let current = this.head;
            let index = 0;
            //使用current作为循环结束的条件 current等于null的时候表示查找结束了，退出循环
            while(current){
                if(current.element == element){
                    return index;
                }
                current = current.next;
                index += 1;
            }
            return -1;
        }

        // update(position,element):修改元素某个位置的值
        DoublyLinkedlist.prototype.update = function(position,element){
            if(position < 0 || position >= this.length){
                return false;
            }
            let index = 0;
            let current = null;
            // falg为true表示从前往后查找更高效
            let flag = this.length / 2 > position;
            if(flag){
              current = this.head;
              while(index < position){
                  index += 1;
                  current = current.next;
              }
            }else{
              current = this.tail;
              while(index < this.length - 1 - position){
                  index += 1;
                  current = current.tail;
              }
            }
            current.element = element;
            return true;
        }

        //reemoveAt(position):删除指定位置的一项
        DoublyLinkedlist.prototype.removeAt = function(position){
            if(position < 0 || position >= this.length){
                return null;
            }
            let current = null;
            if(this.length == 1){
              current = this.head;
              this.head = null;
              this.tail = null;
            }else {
                if(position == 0){
                    current = this.head;
                    current.next.prev = null;//第二个元素的prev指向head
                    this.head = current.next;
                    current.next = null;
                    }else if (position == this.length -1){
                        current = this.tail;
                        current.prev.next = null;
                        current.prev = null;
                        this.tail = current.prev;
                    }else{
                        let index = 0;
                        current = this.head;
                        while(index < position){
                            index += 1;
                            current = current.next;
                        }
                        current.next.prev = current.prev;// 被删除的元素的后一个元素的prev指向被删除元素的前一个元素
                        current.prev.next = current.next;//被删除元素的前一个元素的next指向被删除元素的后一个元素
                        current.next = null;
                        current.prev = null;
                    }
            }
            this.length -= 1;
            return current.element;
        }
        // remove(element)
        DoublyLinkedlist.prototype.remove = function(element){
            let current = this.head;
            if(this.length == 1){
                this.head = null;
                this.tail = null;
            }else{
                //删除的是第一个元素
                if(current.element == element){
                  current.next.prev = null;
                  this.head = current.next;
                }else if(this.tail.element == element){
                    //删除的是最后一个元素
                    current = this.tail;
                    this.tail.prev.next = null;
                    this.tail = this.tail.prev;
                }else{
                    while(current){
                        if(current.element !== element){
                            current = current.next;
                        }else{
                            current.next.prev = current.prev;
                            current.prev.next = current.next;
                            this.length -= 1;
                            return current.element;
                        }
                    }

                }
            }
            this.length -= 1;
            return current.element;
        }

        // 获取长度
        DoublyLinkedlist.prototype.size = function(){
            return this.length;
        }

        // 重写toString方法
        DoublyLinkedlist.prototype.toString = function(){
          return this.backforwardString();
        }
        //向前遍历
        DoublyLinkedlist.prototype.forwardString = function(){
            let str = "";
            let current = this.tail;
            while(current){
                str += "<" + current.element  ;
                current = current.prev;
            }
            return str;
        }
        // 向后遍历
        DoublyLinkedlist.prototype.backforwardString = function(){
            let str = "";
            let current = this.head;
            while(current){
                str += current.element + "->"
                current = current.next;
            }
            return str;
        }
    }


    let doublyLinkedlist = new DoublyLinkedlist();
    doublyLinkedlist.append('a')
    doublyLinkedlist.append('b')
    doublyLinkedlist.append('c')
    doublyLinkedlist.append('d')
    alert(doublyLinkedlist.toString())

    // doublyLinkedlist.insert(0,'hello')
    // alert(doublyLinkedlist.toString())
    // let length = doublyLinkedlist.size();
    // doublyLinkedlist.insert(length-1,'world')
    // alert(doublyLinkedlist.toString())
    doublyLinkedlist.insert(0,'f')
    alert(doublyLinkedlist.toString())
    // alert(doublyLinkedlist.get(0))
    // alert(doublyLinkedlist.get(3))
    // alert(doublyLinkedlist.indexOf('f'))
    // alert(doublyLinkedlist.indexOf('a'))
    // alert(doublyLinkedlist.indexOf('b'))
    // alert(doublyLinkedlist.indexOf('c'))
    // alert(doublyLinkedlist.indexOf('d'))
    // alert(doublyLinkedlist.indexOf('nnn'))
//    if(doublyLinkedlist.update(0,'fixff')){
//     console.log( doublyLinkedlist.indexOf('fixff'))
//    }
    // doublyLinkedlist.removeAt(3)
    doublyLinkedlist.remove('d')
    alert(doublyLinkedlist.toString())

</script>
</html>