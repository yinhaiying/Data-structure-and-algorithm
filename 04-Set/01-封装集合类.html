<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>集合</title>
</head>
<body>
    
</body>
<script>
  
  function Set(){
    //集合类似于数组只是用来保存元素，不涉及到其他指针之类多个值
    //因此只需要一个简单的容器即可。不存在其他内部类之类的。

    //类的属性
    this.items = {}

    //类的操作

    // add(value)
    Set.prototype.add = function(value){
      //判断集合中是否包含有该元素
      if(this.has(value)){
          return false;
      }
       this.items[value] = value; 
       return true;
    }
    // remove(value)
    Set.prototype.remove = function(value){
        if(!this.has(value)){
            return false;
        }
        delete this.items[value];
        return true;
    }
    //clear()
    Set.prototype.clear = function(){
      this.items = {};
    }
    //size()
    Set.prototype.size = function(){
      return Object.keys(this.items).length;
    }
    //values()
    Set.prototype.values = function(){
      return Object.keys(this.items)
    }
    // 判断集合中是否有某属性
    Set.prototype.has = function(value){
       return this.items.hasOwnProperty(value)
    }

    //并集
    Set.prototype.union = function(...args){
       // this本来就是一个集合
       //求this代表的集合和其他集合的并集
       for(let i = 0;i < args.length;i++){
         let values = args[i].values();
         for(let j = 0;j < values.length;j++){
          this.add(values[j])
         }
       }
       return this;
    }
    // 交集
    Set.prototype.intersection = function(otherSet){
      let newSet = new Set();
      let values = otherSet.values();
      for(var i = 0;i < values.length;i++){
        if(this.has(values[i])){
          newSet.add(values[i])
        }
      }
      return newSet;
    }
    //差集
    Set.prototype.differnence = function(otherSet){
      let newSet = new Set();
      let values = this.values();
      //集合2中不在集合1中的元素添加到新集合中
      for(let j = 0;j < values.length;j++){
        if(!otherSet.has(values[j])){
          newSet.add(values[j])
        }
      }
      return newSet;
    }
    // 子集的判断
    Set.prototype.child = function(otherSet){
      let values = this.values();
      if(values.length > otherSet.values().length){
        return false;
      }
      let flag = true;
      for(let i = 0;i < values.length;i++){
        if(!otherSet.has(values[i])){
          console.log('执行了几次')
          flag = false;
        }
      }
      return flag;
    }


  }

let set1 = new Set();
for(let i = 0;i < 7;i++){
  set1.add(i)
}
console.log(set1.values())

let set2 = new Set();
for(let i = 0;i < 3;i++){
  set2.add(i)
}
console.log(set2.values())

let set3 = new Set();
for(let i = 7;i < 13;i++){
  set3.add(i)
}
console.log(set3.values())


// 集合的合并
// let unionSet = set1.union(set2,set3)
// console.log(unionSet.values())


//集合的交集
// let newSet = set1.intersection(set2)
// console.log(newSet.values())

//集合的差集
// let newSet = set1.differnence(set2)
// console.log(newSet.values())

//子集的判断
let isChild = set2.child(set1)
console.log(isChild )

</script>
</html>