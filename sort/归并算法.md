# 归并算法

## 概念
假设有这样一个正整数数组，需要给它们嫩进行排序。
```javascript
let arr = [6,5,3,1,8,7,2,4];
const sort = (arr) => {
    // 若干代码
    return arr;
}
```
分析，对于算法我们通常都由简到繁，也就是说先假设数据很小，然后增加数据量查找规律。
**当数组长度为1时，即[6]：那么只需要返回原数组即可。**
```javascript
const sort = (arr) => {
    return arr;
}
```
**当数组长度为2时，即[6,5]：那么只需要比较这两个数即可**
```javascript
const sort = ([a,b]) =>{
    return a > b ? [b,a] : [a,b];
}
```


**当数组长度为3时，即[6,5,3]**：3个数就无法直接得出结论了，但是我们已经计算出[6,5]的顺序了，得到一个有序数组[5,6],同时数组[3]也能够直接得出有序数组即它本身[3]，因此我们只需要再合并两个有序数组[5,6]和[3]即可得到结论。
**当数组长度为4时，即[6,5,3,1]**：四个数组成的数组，我们目前一直的能够直接得到有序的数组是长度为2或者1，因此我们都将他们拆分成长度为2的数组即，[6,5]和[3,1]。然后分别得到他们的顺序[5,6]和[1,3]这时候再合并[5,6]和[1,3]这两个有序数组即可。
综上所述，我们可以发现我们每次只需要将数组拆分成左右两个数组，然后再将左右数组不断拆分，拆分到数组中只剩下一个或者2个元素，这时候直接就能够得到有序数组，然后再合并左右两个有序数组即可。因此，关键是如何去合并两个有序数组。这就是归并排序的思想：
**分解（Divide）**：将n个元素组成的数组分成个含n/2个元素的子数组。
**解决（Conquer）**：用合并排序法对两个子序列递归的排序。
**合并（Combine）**：合并两个已排序的子序列得到排序结果。
我们可以查看下归并排序的动态演示图。
![归并算法](https://ftp.bmp.ovh/imgs/2020/11/b8433a0a5b31a24e.webp)

## 归并算法的简单实现
### sort：对子序列递归排序
```javascript
const sort = (arr) => {
  let k = arr.length;
  if (k === 1) {
    return arr;
  }
  if( k===2){
      return arr[0] > arr[1] ?[arr[1],arr[0] ]:[arr[1],arr[0]]
  }
  let left = arr.slice(0, parseInt(k / 2));
  let right = arr.slice(parseInt(k / 2));
  // merge 也是复制到一个新的数组
  return merge(sort(left), sort(right));
}
```
如上代码所示：我们不断地分割，当分割的数组长度为1或者2时就很容易得到一个有序数组。然后只需要将有序数组进行合并即可。因此，关键是如何去合并两个有序数组。

### merge：合并两个有序数组
如果是合并两个有序数组，那么思路就清晰很多了。
我们用通俗的话来说，就是将两个手指头放到两个数组的开头，手指头指向的数，谁小就将其放到新的数组中。然后这个手指头往后移动一位，直到移动到这个数组最后。这里许哟昂考虑的是：
1. 如果左边数组先结束了，那么剩下的右边数组值肯定都比左边数组大，因此直接将剩下的数组的值添加到新数组中即可。
2. 同理，如果右边数组先结束了，那么就把左边数组中的值直接添加到新数组中。
```javascript
const merge = (a, b) => {
  let c = [];
  let i = 0;
  let k = 0;
  while (i < a.length || k < b.length) {
    if (i >= a.length) {
      c.push(b[k]);
      k += 1;
    } else if (k >= b.length) {
      c.push(a[i]);
      i += 1;
    } else {
      if (a[i] <= b[k]) {
        c.push(a[i]);
        i += 1;
      } else {
        c.push(b[k]);
        k += 1;
      }
    }
  }
  return c;
};
```
我们使用上面的merge函数测试一下一些有序数组：
```javascript
console.log(merge([],[1]))   // [1]
console.log(merge([5, 6, 7], [1, 2, 3,4]));  // [1,2,3,4,5,6,7]
console.log(merge([1, 3], [2,4,6,7]));  // [1,2,3,4,6,7]
```
这样的话，我们就得到了简易的归并排序算法：
```javascript
const sort = (arr) => {
  let k = arr.length;
  if (k === 1) {
    return arr;
  }
  if( k===2){
      return arr[0] > arr[1] ?[arr[1],arr[0] ]:[arr[1],arr[0]]
  }
  let left = arr.slice(0, parseInt(k / 2));
  let right = arr.slice(parseInt(k / 2));
  // merge 也是复制到一个新的数组
  return merge(sort(left), sort(right));
};
const merge = (a, b) => {
  let c = [];
  let i = 0;
  let k = 0;
  while (i < a.length || k < b.length) {
    if (i >= a.length) {
      c.push(b[k]);
      k += 1;
    } else if (k >= b.length) {
      c.push(a[i]);
      i += 1;
    } else {
      if (a[i] <= b[k]) {
        c.push(a[i]);
        i += 1;
      } else {
        c.push(b[k]);
        k += 1;
      }
    }
  }
  return c;
};
```
我们使用sort方法进行排序:
```javascript
console.log(sort([1,3,2,4,5,6,7]));   // [1,2,3,4,5,6,7]
console.log(sort([5,8,1,3,2,0,4]));   // [ 0, 1, 2, 3, 4, 5, 8 ]
```